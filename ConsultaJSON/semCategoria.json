{
	"Binary Search":{
		"prefix":"Binary_Search",
		"body":["int binarySearch (int array [], int value, int start , int end){",
			"\tint i = (end + start)/2;",
			"\tif (array[i] == value ){",
			"\t\treturn 1;",
			"\t}",
			"\tif ( start >= end){",
			"\t\treturn 0;",
			"\t}",	
			"\tif (array[i]< value){",
			"\t\treturn binarySearch(array,value, i+1, end);",
			"\t}else{",
			"\t\treturn binarySearch(array,value, start , i-1);",
			"\t}",
			"}"
		],
		"description": "Binary Search"
	},
	"MaxIntervlaosDisjuntos":{
		"prefix":"MaxIntervalosDisjuntos",
		"body":["bool ord(pii a, pii b){",
			"\treturn a.fi > b.fi;",
			"}\n",
			"int MaxIntervalosDisjuntos(int n, vpii &ent, vpii &sai){              //n intervalos",
			"\tsort(all(ent), ord);                                                 //ent -> inicio de cada intervalo, numero intervalo",
			"\tsort(all(sai), ord);                                                 //sai -> fim de cada intervalo, numero intervalo",
			"\tint ind1 = 0, ind2 = 0, cur = 0;",
			"\twhile (ind2 < n){",
			"\t\tif (ent[ind1].fi >= sai[ind2].fi){",
			"\t\t\tcont[sai[ind2].se] = cont[ent[ind1].se] + 1;",
			"\t\t\tif (cont[sai[ind2].se] > cur) cur = cont[sai[ind2].se];",
			"\t\t\tind1++;",
			"\t\t}else{",
			"\t\t\tcont[sai[ind2].se] = cur;",
			"\t\t\tind2++;",
			"\t\t}", 
			"\t}",
			"\treturn cur + 1;",
			"}"
		],
		"description":"Maximo de filmes que posso ver sem ter de sair a meio"
	},
	"MaxIntervalosIntercetados":{
		"prefix":"MaxIntervalosIntercetados",
		"body":["int MaxIntervalosIntercetados(int n, vi &ent, &sai){                 //n intervalos",
			"\tsort(all(ent));                                                //ent -> inicio de cada intervalo",
			"\tsort(all(sai));                                                //sai -> fim de cada intervalo",
			"\tint ind1 = 0, ind2 = 0, cur = 0, maxi = 0;",
			"\twhile (ind1 < n){",
			"\t\tif (ent[ind1] < sai[ind2]){",
			"\t\t\tcur++;",
			"\t\t\tif (cur > maxi) maxi = cur;",
			"\t\t\tind1++;",
			"\t\t}else{",
			"\t\t\tcur--;",
			"\t\t\tind2++;",
			"\t\t}",
			"\t}",
			"\tcout<<maxi<<endl;",
			"}"
		],
		"description":"Maximo de clientes que estão ao mesmo tempo no restaurante"
	},
	"MaiorPrecoPossivelNoMomento":{
		"prefix":"MaiorPrecoPossivelNoMomento",
		"body":["bool ord(int a, int b){",
			"\treturn a > b;",
			"}\n",
			"bool ord2(pii a, pii b){",
			"\treturn a.se > b.se;",
			"}\n",
			"bool ord3(pii a, pii b){",
			"\treturn a.fi < b.fi;",
			"}\n",
			"vi MaiorPrecoPossivelNoMomento(int n, int m, vi &preco, vpii &cli){                  //n produtos",
			"\tsort(all(preco), ord);                                                         //m clientes",
			"\tsort(all(cli), ord2);                                                          //preco -> preco dos produtos",
			"\tpriority_queue<pii, vpii, greater<pii>> pq;                                    //cli -> numero cliente, maximo que cada cliente pode pagar",
			"\tint pre = 0, fim = 0;",
			"\twhile ((pre < n) && (fim < m)){",
			"\t\tif (cli[fim].se >= preco[pre]){",
			"\t\t\tpq.push(cli[fim]);",
			"\t\t\tfim++;",
			"\t\t}else{",
			"\t\t\tif (!pq.empty()){",
			"\t\t\t\tpii aux = pq.top();",
			"\t\t\t\tpq.pop();",
			"\t\t\t\tres[aux.fi] = preco[pre];",
			"\t\t\t}",
			"\t\t\tpre++;",
			"\t\t}",
			"\t}",
			"\twhile ((!pq.empty()) && (pre < n)){",
			"\t\tpii aux = pq.top();",
			"\t\tpq.pop();",
			"\t\tres[aux.fi] = preco[pre];",
			"\t\tpre++;",
			"\t}",
			"return res;",
			"}"
		],
		"description":"Maior preço de bilhetes disponiveis para vender a cada cliente que vai aparecendo"
	},
	"MinimoConjuntosDe2":{
		"prefix":"MinimoConjuntoDe2",
		"body":["bool ord(int a, int b){", 
			"\treturn a > b;",
			"}\n",
			"int MinimoConjuntosDe2(int n, int x, vi &gordos, vi &magros){                       //n pessoas",
			"\tint c = 0, resto = 0, ind = 0;                                                //x peso maximo de cada grupo",
			"\tsort(all(gordos));                                                            //gordos -> pessoas acima de x/2",
			"\tsort(all(magros), ord);                                                       //magros -> pessoas abaixo ou igual a x/2",
			"\tint tam = (int) gordos.size();",
			"\tfor (int num: magros){",
			"\t\tif ((ind < tam) && ((num + gordos[ind]) <= x)){",
			"\t\t\tc++;",
			"\t\t\tind++;",
			"\t\t}else{",
			"\t\t\tresto++;",
			"\t\t}",
			"\t}",
			"\tc += resto/2 + resto%2 + (tam - ind);",
			"\tcout<<c<<endl;",
			"}"
		],
		"description":"Menor número de conjunto (de 2) que se pode fazer sabendo o peso de todos"
	},
	"Junta2Intervalos":{
		"prefix":"juntaInter",
		"body":["pll junta(pll a, pll b){",
			"\tif (a.fi < b.se && a.se > b.fi){",
			"\t\treturn mp(max(a.fi, b.fi), min(a.se, b.se));",
			"\t}else{",
			"\t\treturn mp(-1, -1);",
			"\t}",
			"}"
		],
		"description":"Devolve a interseção de 2 conjuntos, se for possível"
	},
	"Permutacoes":{
		"prefix":"permutacoes",
		"body":["//l = 0, r = n-1",
						"void permute(vector<int> &a, int l, int r){",
						"\tif (l == r){",
						"\t\t//verificar permutação, guardá-la leva a MLE",
						"\t\tverifica();",
						"\t}",
						"\telse{",
						"\t\t//Fazer todas as permutacoes",
						"\t\tfor (int i = l; i <= r; i++){",
						"\t\t\tswap(a[l], a[i]);",
						"\t\t\tpermute(a, l+1, r);",
						"\t\t\tswap(a[l], a[i]);",
						"\t\t}",
						"\t}",
						"}"
			],
		"description":"Faz todas as permutacoes de uma lista em n!"
	}
}
