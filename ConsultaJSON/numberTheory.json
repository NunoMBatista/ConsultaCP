{
	"Algortimos para numeros primos":{
		"prefix":"primos",
		"body":["ll sieve_size;",
			"bitset<10000010> bs;",
			"vll p;\n",
			"void gerador(ll upperbound){                //Não maior de 10^7",
			"\tsieve_size = upperbound+1;",
			"\tbs.set();",
			"\tbs[0] = bs[1] = 0;",
			"\tfor (ll i = 0; i < sieve_size; i++){",
			"\t\tif (bs[i]){",
			"\t\t\tfor (ll j = i*i; j < sieve_size; j+=i) bs[j] = 0;",
			"\t\t\tp.push_back(i);",
			"\t\t}",
			"\t}",
			"}\n",
			"bool isPrime(ll N){",
			"\tif (N < sieve_size) return bs[N];",
			"\tfor (int i = 0; i < (int) p.size() && p[i]*p[i] <= N; i++){",
			"\t\tif (N%p[i] == 0) return false;",
			"\t}",
			"\treturn true;",
			"}\n",
			"//Por no solve",
			"gerador(10000000);\n",
			"vll primeFactor(ll N){      //Fatorizar em numeros primos, não esquecer de gerar numeros primos",
			"\tvll factors;",
			"\tint tam = p.size();",
			"\tfor (int i = 0; (i < tam) && (p[i]*p[i] <= N); i++){",
			"\t\twhile (N%p[i] == 0){",
			"\t\t\tN /= p[i];",
			"\t\t\tfactors.pb(p[i]);",
			"\t\t}",
			"\t}",
			"\tif (N != 1) factors.pb(N);",
			"\treturn factors;",
			"}\n",
			"int numFatPrimos(ll N){     //Quantos fatores primos tem um numero",
			"\tint ans = 1;",
			"\tfor (int i = 0; (i < (int) p.size()) && (p[i]*p[i] <= N); i++){",
			"\t\twhile (N%p[i] == 0) {",
			"\t\t\tN/=p[i];",
			"\t\t\tans++;",
			"\t\t}",
			"\t}",
			"\treturn ans + (N != 1);",
			"}\n",
			"int numDivisores(ll N){          //Multiplicatorio de (n+1), sendo 'n' o numero de vezes que cada fator primos aparece",
			"\tint ans = 0;",
			"\tfor (int i = 0; (i < (int) p.size()) && (p[i]*p[i] <= N); i++){",
			"\t\tint power = 0;",
			"\t\twhile (N%p[i] == 0){",
			"\t\t\tN /= p[i];",
			"\t\t\t++power;",
			"\t\t}",
			"\t\tans *= power+1;",
			"\t}",
			"\treturn (N != 1) ? 2*ans : ans;",
			"}\n",
			"ll sumDivisores(ll N){          //Multiplicatório de (a^(n+1) - 1)/(a-1), sendo 'a' cada fator primo e 'n' o número de vezes que 'a' se repete",
			"\tll ans = 1;",
			"\tfor (int i = 0; (i < (int) p.size()) && (p[i]*p[i] <= N); i++){",
			"\t\tll multiplier = p[i], total = 1;",
			"\t\twhile (N%p[i] == 0){",
			"\t\t\tN /= p[i];",
			"\t\t\ttotal += multiplier;",
			"\t\t\tmultiplier *= p[i];",
			"\t\t}",
			"\t\tans *= total;",
			"\t}",
			"\tif (N != 1) ans *= (N+1);",
			"\treturn ans;",
			"}\n",
			"ll numCoprimos(ll N){       //N * Multiplicatorio de (1 - 1/a), sendo 'a' cada fator primo de N",
			"\tll ans = N;",
			"\tfor (int i = 0; (i < (int) p.size()) && (p[i]*p[i] <= N); i++){",
			"\t\tif (N%p[i] == 0) ans -= ans/p[i];",
			"\t\twhile (N%p[i] == 0) N/=p[i];",
			"\t}",
			"\tif (N != 1) ans -= ans/N;",
			"\treturn ans;",
			"}\n ",
			"vi numDiffFatPrimos(ll MAX_N){    //MAX_N <= 10^7       Numero de fatores primos diferentes para mt queries",
			"\tvi arr(MAX_N + 10, 0);",
			"\tfor (int i = 2; i <= MAX_N; i++){",
			"\t\tif (arr[i] == 0){",
			"\t\t\tfor (int j = i; j <= MAX_N; j+=i){",
			"\t\t\t\t++arr[j];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn arr;",
			"}\n",
			"vi numCoprimosMtQueries(ll Max_n){      //Max_n <= 10^7     Numero de coprimos para mt queries",
			"\tvi arr(Max_n);",
			"\tfor (int i = 1; i <= Max_n; i++) arr[i] = i;",
			"\tfor (int i = 2; i <= Max_n; i++){",
			"\t\tif (arr[i] == i){",
			"\t\t\tfor (int j = i; j <= Max_n; j+=i){",
			"\t\t\t\tarr[j] = (arr[j]/i) * (i-1);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn arr;",
			"}"
		],
		"description":"Verificar se é primo, fatorização em primos, contador de divisores, fatores primos e coprimos, soma de divisores"
	},
	"Number Theory":{
		"prefix":["NumberTheory", "Euclidean", "GCD", "LCM", "InvModulo", "Catalan", "ChineseRT"],
		"body":[
			"int extEuclidean(int a, int b, int &x, int &y){",
			"\tint xx = y = 0;",
			"\tint yy = x = 1;",
			"\twhile (b){",
			"\t\tint q = a/b;",
			"\t\tint t = b;",
			"\t\tb = a%b;",
			"\t\ta = t;",
			"\t\tt = xx;",
			"\t\txx = x-q*xx;",
			"\t\tx = t;",
			"\t\tt = yy;",
			"\t\tyy = y - q*yy;",
			"\t\ty = t;",
			"\t}",
			"\treturn a;",
			"}\n",
			"int modInverse(int A, int M){          //Para combinações/fatoriais, escrever comb ou fatoriais",
			"\tint x, y",
			"\tint d = extEuclidean(A, M, x, y);",
			"\tif (d != 1) return -1;",
			"\treturn mod(x, M);",
			"}\n",
			"pii diophantine(int a, int b, int sol){         //a*x + b*y = sol",
			"\tint x, y;",
			"\tint d = extEuclidean(a, b, x, y);           //gcd(a, b)    ",
			"\tint mult = sol/d;",
			"\tx *= mult;",
			"\ty *= mult;",
			"\tb /= d;",
			"\ta /= d;",
			"\tint liminf = 0, limsup = INF;",
			"\tif ((x < 0) != (b < 0)){",
			"\t\tliminf = abs(x/b);",
			"\t\tif (x%b) liminf++;",
			"\t}else{",
			"\t\tlimsup = abs(x/b);",
			"\t}",
			"\tif ((y < 0) != (a < 0)){",
			"\t\tint aux = abs(y/a);",
			"\t\tif (y%a) aux++;",
			"\t\tliminf = max(liminf, aux);",
			"\t}else{",
			"\t\tlimsup = min(limsup, abs(y/a));",
			"\t}",
			"\tif (liminf > limsup) return mp(-1, -1);         //Só devolve uma solução para a equação, mas há um limite (finito ou infinito de soluções)",
			"\telse return mp(x + b*liminf, y + a*liminf);",
			"}\n",
			"int crt(vi &r, vi &m){",
			"\tint mt = accumulate(m.begin(), m.end(), 1, multiplies<>());",
			"\tint x = 0;",
			"\tfor (int i = 0; i < (int) m.size(); i++){",
			"\t\tint a = mod((ll)r[i] * modInverse(mt/m[i], m[i]), m[i]);",
			"\t\tx = mod(x + (ll)a * (mt/m[i]), mt);",
			"\t}",
			"\treturn x;",
			"}\n",
			"vll Catalan(int n, ll m){                  //n inclusive",
			"\tvll cat(n+1);",
			"\tcat[0] = 1;",
			"\tfor (int i = 0; i < n; i++){",
			"\t\tcat[i+1] = mod(mod(mod((4*i)+2,m) * mod(cat[i],m), m) * modInverse(i+2, m),m);",
			"\t}",
			"\treturn cat;",
			"}\n",
			"inline long long int gcd(int a, int b){",
			"\twhile (b) {",
			"\t\ta %= b;",
			"\t\tswap(a, b);",
			"\t}",
			"\treturn a;",
			"}\n",
			"inline long long int lcm (int a, int b){",
			"\treturn (a / gcd(a, b)) * b;",
			"}"
		],
		"description":"Algoritmos de Euclides, Diophanes (ax + by = c), gcd, lcm, inverso do módulo, Sequencia de Catalan, Chinese Remainder Theorem"
	},
	"Combinacoes":{
		"prefix":["comb", "fatoriais"],
		"body":["int modInverse(int A, int M){",
			"\tint m0 = M;",
			"\tint y = 0, x = 1;\n",
			"\tif (M == 1)",
			"\t\treturn 0;\n",
			"\twhile (A > 1) {",
			"\t\t// q is quotient",
			"\t\tint q = A / M;",
			"\t\tint t = M;\n",
			"\t\t// m is remainder now, process same as",
			"\t\t// Euclid's algo",
			"\t\tM = A % M, A = t;",
			"\t\tt = y;\n",
			"\t\t// Update y and x",
			"\t\ty = x - q * y;",
			"\t\tx = t;",
			"\t}\n",
			"\t// Make x positive",
			"\tif (x < 0)",
			"\t\tx += m0;\n", 
			"\treturn x;",
			"}\n",
			"vpll fat;\n",
			"void fatoriais(int tam, int m, vpll &res){",
			"\tres.pb(mp(1,1));",
			"\tfor (int j = 1; j <= tam; j++){",
			"\t\tres.pb(mp((res[j-1].fi*j)%m, 0));",
			"\t}",
			"\tll inv = modInverse(res[tam].fi, m);",
			"\tres[tam].se = inv;",
			"\tfor (int j = tam-1; j > 0; j--){",
			"\t\tres[j].se = (res[j+1].se*(j+1))%m;",
			"\t}",
			"}\n",
			"ll comb(int c, int d, int m){",
			"\tif (d == 0) return 1;",
			"\tif ((d > 0) && (d > c)) return 0;",
			"\treturn (((fat[c].fi*fat[d].se)%m)*fat[c-d].se)%m;",
			"}",
			"fatoriais(5000, MOD, fat);                                 //Colocar dentro da main"
		],
		"description":"Combinações e fatoriais, em módulo m"
	}
}
