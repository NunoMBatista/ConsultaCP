{
	"Dijkstra": {
		"prefix": "Dijkstra",
		"body":["vector<int> dijkstra(vector<vector<pii>>& graph, int source, int target) {",
			"\tint n = graph.size();",
			"\tvector<int> dist(n, INF);",
			"\tvector<bool> visited(n, false);",
			"\tdist[source] = 0;",
			"\tpriority_queue<pii, vector<pii>, greater<pii>> pq;",
			"\tpq.push(make_pair(0, source));",
			"\twhile (!pq.empty()) {",
			"\t\tint u = pq.top().second;",
			"\t\tpq.pop();",
			"\t\tif (visited[u]) {",
			"\t\t\tcontinue;",
			"\t\t}",
			"\t\tvisited[u] = true;",
			"\t\tif (u == target) {",
			"\t\t\tbreak;",
			"\t\t}",
			"\t\tfor (auto& neighbor : graph[u]) {",
			"\t\t\tint v = neighbor.first;",
			"\t\t\tint weight = neighbor.second;",
			"\t\t\tif (dist[v] > dist[u] + weight) {",
			"\t\t\t\tdist[v] = dist[u] + weight;",
			"\t\t\t\tpq.push(make_pair(dist[v], v));",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn dist;",
			"}"
		],
		"description": "Algoritmo de Dijkstra"
	},
	"Disjoint Set Union": {
		"prefix": "DSU",
		"body":["//Cada valor começa por ser o seu proprio set",
			"void makeSet(int v, vi &parent) {",
			"\tparent[v] = v;",
			"}",
			"int findSet(int v, vi &parent) {",
			"\tif (v != parent[v])",
			"\tparent[v] = findSet(parent[v], parent);",
			"\treturn parent[v];",
			"}",
			"void unionSets(int u, int v, vi &parent) {",
			"\tint root1 = findSet(u, parent);",
			"\tint root2 = findSet(v, parent);",
			"\tparent[root2] = root1;",
			"}",
			"bool check(int u, int v, vi &parent) {",
			"\treturn findSet(u, parent) == findSet(v, parent);",
			"}"
		],
		"description":"Disjoint Set Union: juntar árvores (quando só importa em que árvore está o vértice e não a ligação a que vértice)"
	},
	"DFS":{
		"prefix": "DFS",
		"body":["void dfs (int v, vector<bool> &visited, vv &adjMat){",
			"\tvisited[v] = true;",
			"\tfor(int no: adjMat[v]){",
			"\t\tif (!visited[no]){",
			"\t\t\tdfs(no, visited, adjMat);",
			"\t\t}",
			"\t}",
			"\treturn;",
			"}"
		],
		"description":"dfs"
	},
	"Strongly Connected Components":{
		"prefix": ["SCC","Tarjan"],
		"body":["vector<vector<ll>> graph;",
						"vector<vector<ll>> SCCs;",
						"vector<bool> visited;",
						"vector<ll> ids; ",
						"vector<ll> low;",
						"ll counter; ",
						"stack<ll> S;",
						"vector<bool> onStack;",
						"ll id;\n",
						"void dfs(ll cur){",
						"\tS.push(cur);",
						"\tonStack[cur] = true;",
						"\tids[cur] = low[cur] = id;",
						"\tid++;",
						"\tfor(auto adj: graph[cur]){",
						"\t\tif(ids[adj] == -1){",
						"\t\t\tdfs(adj);",
						"\t\t}",
						"\t\t// If statement after the DFS callback",
						"\t\tif(onStack[adj]){",
						"\t\t\tlow[cur] = min(low[cur], low[adj]);",
						"\t\t}",
						"\t}",
						"\t// SCC root found",
						"\tll top = -1;",
						"\tif(ids[cur] == low[cur]){",
						"\t\tvector<ll> newSCC;",
						"\t\twhile(top != cur){",
						"\t\t\ttop = S.top(); S.pop();",
						"\t\t\tonStack[top] = false;",
						"\t\t\tlow[top] = ids[cur];",
						"\t\t\tnewSCC.push_back(top);",
						"\t\t}",
						"\t\tSCCs.push_back(newSCC);",
						"\t\tcounter++;",
						"\t}",
						"}\n",
						"void tarjan(){",
						"\tid = 1;",
						"\tcounter = 0;",
						"\tfor(ll i = 1; i <= n; ++i){",
						"\t\tif(ids[i] == -1){",
						"\t\t\tdfs(i);",
						"\t\t}",
						"\t}",
						"}"
		],
		"description":"Encontrar nucleos de vertices que a partir de qualquer vertice é possível chegar a qualquer outro"
	},
	"BFS":{
		"prefix":"BFS",
		"body":["void BFS(int v, vv &graph){",
			"\tvector<bool> visited((int) graph.size(), false);",
			"\tvisited[v] = true;",
			"\tqueue<int> q;",
			"\tq.push(v);",
			"\twhile (!q.empty()){",
			"\t\tint u = q.front();",
			"\t\tq.pop();",
			"\t\tif (!visited[u]){",
			"\t\t\tvisited[u] = true;",
			"\t\t\tfor(int s: graph[u]){",
			"\t\t\t\tq.push(s);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "Breath-First Search"
	},
	"MaxFlowMinCut":{
			"prefix":["MaxFlowMinCutT", "EdmondsKarpT"],
			"body":["template<class T> void dfs(int s, vector<unordered_map<int, T>> &graph, vv &adjacency, vb &visited){",
							"\tvisited[s] = true;",
							"\tfor (int ver: adjacency[s]){",
							"\t\tif (!visited[ver] && graph[s][ver] != 0){",
							"\t\t\tdfs(ver, graph, adjacency, visited);",
							"\t\t}",
							"\t}",
							"}",
							"",
							"#define rep(i, a, b) for(int i = a; i < (b); ++i)",
							"template<class T> T edmondsKarp(vector<unordered_map<int, T>>&graph, int source, int sink, vpii *arestas = NULL) {",
							"\tassert(source != sink);",
							"\tT flow = 0;",
							"\tvi par(sz(graph)), q = par;",
							"\tint n = graph.size();",
							"\tvv adjacency(n);",
							"\tif (arestas){",
							"\t\tfor (int i = 0; i < n; i++){",
							"\t\t\tfor (pii are: graph[i]){",
							"\t\t\t\tadjacency[i].pb(are.fi);",
							"\t\t\t}",
							"\t\t}",
							"\t}",
							"\tfor (;;) {",
							"\t\tfill(all(par), -1);",
							"\t\tpar[source] = 0;",
							"\t\tint ptr = 1;",
							"\t\tq[0] = source;",
							"",
							"\t\trep(i,0,ptr) {",
							"\t\t\tint x = q[i];",
							"\t\t\tfor (auto e : graph[x]) {",
							"\t\t\t\tif (par[e.first] == -1 && e.second > 0) {",
							"\t\t\t\tpar[e.first] = x;",
							"\t\t\t\tq[ptr++] = e.first;",
							"\t\t\t\tif (e.first == sink) goto out;",
							"\t\t\t\t}",
							"\t\t\t}",
							"\t\t}",
							"\t\tif (arestas){",
							"\t\t\tvb visited(n, false);",
							"\t\t\tdfs(source, graph, adjacency, visited);",
							"\t\t\tfor (int i = 0; i < n; i++){",
							"\t\t\t\tfor (pair<int, T> ver: graph[i]){",
							"\t\t\t\t\tif (!visited[i] && visited[ver.fi] && graph[ver.fi][i] == 0){",
							"\t\t\t\t\t\t(*arestas).pb(mp(ver.fi, i));",
							"\t\t\t\t\t}",
							"\t\t\t\t}",
							"\t\t\t}",
							"\t\t}",
							"\t\treturn flow;",
							"out:",
							"\t\tT inc = numeric_limits<T>::max();",
							"\t\tfor (int y = sink; y != source; y = par[y])",
							"\t\t\tinc = min(inc, graph[par[y]][y]);",
							"",
							"\t\tflow += inc;",
							"\t\tfor (int y = sink; y != source; y = par[y]) {",
							"\t\t\tint p = par[y];",
							"\t\t\tif ((graph[p][y] -= inc) <= 0) graph[p].erase(y);",
							"\t\t\tgraph[y][p] += inc;",
							"\t\t}",
							"\t}",
							"}"
					],
		"description":"MaxFlowMinCut com a possibilidade de pair<int, int>"
	},
	"MinCostMaxFlow":{
		"prefix":"MinCostMaxFlow",
		"body":["typedef tuple<int, ll, ll, ll> edge;",
						"class min_cost_max_flow {",
						"private:",
						"\tint V;",
						"\tll total_cost;",
						"\tvector<edge> EL;",
						"\tvector<vi> AL;",
						"\tvll d;",
						"\tvi last, vis;",
						"",
						"\tbool SPFA(int s, int t) { // SPFA to find augmenting path in residual graph",
						"\t\td.assign(V, INF); d[s] = 0; vis[s] = 1;",
						"\t\tqueue<int> q({s});",
						"\t\twhile (!q.empty()) {",
						"\t\t\tint u = q.front(); q.pop(); vis[u] = 0;",
						"\t\t\tfor (auto &idx : AL[u]) {                  // explore neighbors of u",
						"\t\t\t\tauto &[v, cap, flow, cost] = EL[idx];          // stored in EL[idx]",
						"\t\t\t\tif ((cap-flow > 0) && (d[v] > d[u] + cost)) {      // positive residual edge",
						"\t\t\t\t\td[v] = d[u]+cost;",
						"\t\t\t\t\tif(!vis[v]) q.push(v), vis[v] = 1;",
						"\t\t\t\t}",
						"\t\t\t}",
						"\t\t}",
						"\t\treturn d[t] != INF;                           // has an augmenting path",
						"\t}",
						"",
						"\tll DFS(int u, int t, ll f = INF) {             // traverse from s->t",
						"\t\tif ((u == t) || (f == 0)) return f;",
						"\t\tvis[u] = 1;",
						"\t\tfor (int &i = last[u]; i < (int)AL[u].size(); ++i) { // from last edge",
						"\t\t\tauto &[v, cap, flow, cost] = EL[AL[u][i]];",
						"\t\t\tif (!vis[v] && d[v] == d[u]+cost) {                      // in current layer graph",
						"\t\t\t\tif (ll pushed = DFS(v, t, min(f, cap-flow))) {",
						"\t\t\t\t\ttotal_cost += pushed * cost;",
						"\t\t\t\t\tflow += pushed;",
						"\t\t\t\t\tauto &[rv, rcap, rflow, rcost] = EL[AL[u][i]^1]; // back edge",
						"\t\t\t\t\trflow -= pushed;",
						"\t\t\t\t\tvis[u] = 0;",
						"\t\t\t\t\treturn pushed;",
						"\t\t\t\t}",
						"\t\t\t}",
						"\t\t}",
						"\t\tvis[u] = 0;",
						"\t\treturn 0;",
						"\t}",
						"",
						"public:",
						"\tmin_cost_max_flow(int initialV) : V(initialV), total_cost(0) {",
						"\t\tEL.clear();",
						"\t\tAL.assign(V, vi());",
						"\t\tvis.assign(V, 0);",
						"\t}",
						"",
						"\t// if you are adding a bidirectional edge u<->v with weight w into your",
						"\t// flow graph, set directed = false (default value is directed = true)",
						"\tvoid add_edge(int u, int v, ll w, ll c, bool directed = true) {",
						"\t\tif (u == v) return;                          // safeguard: no self loop",
						"\t\tEL.emplace_back(v, w, 0, c);                 // u->v, cap w, flow 0, cost c",
						"\t\tAL[u].push_back(EL.size()-1);                // remember this index",
						"\t\tEL.emplace_back(u, 0, 0, -c);                // back edge",
						"\t\tAL[v].push_back(EL.size()-1);                // remember this index",
						"\t\tif (!directed) add_edge(v, u, w, c);         // add again in reverse",
						"\t}",
						"",
						"\tpair<ll, ll> mcmf(int s, int t) {",
						"\t\tll mf = 0;                                   // mf stands for max_flow",
						"\t\twhile (SPFA(s, t)) {                          // an O(V^2*E) algorithm",
						"\t\t\tlast.assign(V, 0);                         // important speedup",
						"\t\t\twhile (ll f = DFS(s, t))                   // exhaust blocking flow",
						"\t\t\t\tmf += f;",
						"\t\t}",
						"\t\treturn {mf, total_cost};",
						"\t}",
						"};",
						"",
						"void solve(){",
						"\tint v, e, s, t;",
						"\tcin>>v>>e>>s>>t;",
						"\tmin_cost_max_flow mf(v);",
						"\tfor (int i = 0; i < e; i++){",
						"\t\tint a, b, cap, cost;",
						"\t\tcin>>a>>b>>cap>>cost;",
						"\t\tmf.add_edge(a, b, cap, cost);",
						"\t}",
						"\tpll res = mf.mcmf(s, t);",
						"\tcout<<res.fi<<' '<<res.se<<endl;",
						"}"
		],
		"description":"Custo minimo para chegar ao sink com um limite maximo no fluxo"
	},
	"Articulation Points":{
		"prefix":["AP", "Articulation Points"],
		"body":["void AP(int v, vv &adj, vb &check, vi &dfs, vi &low, vi &parent, int &t, int &c){",
						"\tlow[v] = dfs[v] = t++;",
						"\tfor (auto nbr: adj[v]){",
						"\t\tif (dfs[nbr] == 0){",
						"\t\t\tparent[nbr] = v;",
						"\t\t\tAP(nbr, adj, check, dfs, low, parent, t, c);",
						"\t\t\tlow[v] = min(low[v], low[nbr]);",
						"\t\t\tif (!check[v]){",
						"\t\t\t\tif (dfs[v] == 1){",
						"\t\t\t\t\tif (dfs[nbr] != 2) c++;",
						"\t\t\t\t}else{",
						"\t\t\t\t\tif (low[nbr] >= dfs[v]) c++;",
						"\t\t\t\t}",
						"\t\t\t}",
						"\t\t\tcheck[v] = true;",
						"\t\t}else if (parent[v] != nbr){",
						"\t\t\tlow[v] = min(low[v], dfs[nbr]);",
						"\t\t}",
						"\t}",
						"}",
						"",
						"void solve(){",
						"\tint n, m;",
						"\tcin>>n>>m;",
						"\tvv adj(n+1);",
						"\tvb check(n+1);",
						"\tvi dfs(n+1, 0);",
						"\tvi low(n+1, -1);",
						"\tvi parent(n+1, -1);",
						"\tint t = 1;",
						"\tint c = 0;",
						"\tAP(1, adj, check, dfs, low, parent, t, c);",
						"}"
		],
		"description":"Quantos nós, quando retirados, tornam o grafo desconexo"
	},
	"Bellman-Ford":{
			"prefix":"BellmanFord",
			"body":["vi BF(vvpii &adjList, int source){",
							"\tint n = adjList.size();",
							"\tvi dist(n+1, INF);",
							"\tdist[source] = 0;",
							"\tfor (int i = 1; i < n; i++){",
							"\t\tbool modified = false;",
							"\t\tfor (int j = 1; j <= n; j++){",
							"\t\t\tif (dist[j] != INF){",
							"\t\t\t\tfor (auto nbr: adjList[j]){",
							"\t\t\t\t\tint v = nbr.fi;",
							"\t\t\t\t\tint weight = nbr.se;",
							"\t\t\t\t\tif (dist[v] > dist[j] + weight){",
							"\t\t\t\t\t\tdist[v] = dist[j] +weight;",
							"\t\t\t\t\t\tmodified = true;",
							"\t\t\t\t\t}",
							"\t\t\t\t}",
							"\t\t\t}",
							"\t\t}",
							"\t\tif (!modified) break;",
							"\t}",
							"\tbool hasNegativeCycle = false;",
							"\tfor (int i = 1; i <= n; i++){",
							"\t\tif (dist[i] != INF){",
							"\t\t\tfor (auto nbr: adjList[i]){",
							"\t\t\t\tint v = nbr.fi;",
							"\t\t\t\tint weight = nbr.se;",
							"\t\t\t\tif (dist[v] > dist[i] + weight){",
							"\t\t\t\t\thasNegativeCycle = true;",
							"\t\t\t\t}",
							"\t\t\t}",
							"\t\t}",
							"\t}",
							"\tif (hasNegativeCycle){",
							"\t\tfor (int i = 0; i <= n; i++){ ",
							"\t\t\tdist[i] = -1;",
							"\t\t}",
							"\t}",
							"\treturn dist;",
							"}"
		],
		"description":"Distancia minima de um nó a todos os outros"
	},
	"Floyd-Warshall":{
		"prefix":"FloydWarshall",
		"body":["void FW(vv &matrix, vv *p = NULL){",
						"\tint numVertices = (int) matrix.size();",
						"\tif (p){",
						"\t\tfor (int i = 0; i < numVertices; i++){",
						"\t\t\tfor (int j = 0; j < numVertices; j++){",
						"\t\t\t\tp[i][j] = i;",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\tfor (int k = 0; k < numVertices; k++){",
						"\t\tfor (int i = 0; i < numVertices; i++){",
						"\t\t\tfor (int j = 0; j < numVertices; j++){",
						"\t\t\t\tif (matrix[i][k] != INT_MAX && matrix[k][j] != INT_MAX){",
						"\t\t\t\t\tmatrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);",
						"\t\t\t\t\tif (p) p[i][j] = p[k][j];",
						"\t\t\t\t}",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"}\n",
						"void printPath(int i, int j){\t\t\t\t\t//Nao sei se esta funcao esta 100% correta mas a ideia está la",
						"\tif (i != j) printPath(i, p[i][j]);",
						"\tcout<<j<<endl;",
						"}"
		],
		"description":"Distancia minima de todos os vertices a todos os vertices"
	},
	"Eulariano":{
		"prefix":"Eulariano",
		"body":["//Para grafo direcionado, nao é preciso arestas. Guarda-se o vertices de saida diretamente na list",
						"//Verificar se é conexo (dfs) e todos os vertices têm grau par. Para semi-eulariano, 2 vertices com grau impar, restantes par",
						"vi hierholzer(int s, vector<list<int>> &graph, vector<pair<pii, bool>> &arestas){",
						"\tint n = graph.size();",
						"\tvi ans, idx(n, 0), st;",
						"\tst.pb(s);",
						"\twhile (!st.empty()){",
						"\t\tint u = st.back();",
						"\t\t//ciclo nao necessario para grafo direcionado",
						"\t\twhile (!graph[u].empty() && arestas[graph[u].front()].se){",
						"\t\t\tgraph[u].pop_front();",
						"\t\t}",
						"\t\tif (!graph[u].empty()){",
						"\t\t\tpii are = arestas[graph[u].front()].fi;",
						"\t\t\tif (are.fi == u) st.pb(are.se);",
						"\t\t\telse st.pb(are.fi);",
						"\t\t\tarestas[graph[u].front()].se = true;",
						"\t\t\tgraph[u].pop_front();",
						"\t\t}else{",
						"\t\t\tans.pb(u);",
						"\t\t\tst.pop_back();",
						"\t\t}",
						"\t}",
						"\treverse(all(ans));",
						"\treturn ans;",
						"}"
		],
		"description":"Encontra caminho eulariano e semi-eulariano"
	},
	"Lowest Common Ancestor":{
		"prefix":"LCA",
		"body":["void dfs(int cur, int depth, vv &adjMatrix, vb &visited, vi &L, vi &E, vi &H, int &idx){",
						"  H[cur] = idx;",
						"  E[idx] = cur;",
						"  L[idx++] = depth;",
						"  visited[cur] = true;",
						"  for (int nxt: adjMatrix[cur]){",
						"    if (!visited[nxt]){",
						"      dfs(nxt, depth+1, adjMatrix, visited, L, E, H, idx);",
						"      E[idx] = cur;",
						"      L[idx++] = depth;",
						"    }",
						"  }",
						"}\n",
						"void buildRMQ(int n, vv &adjMatrix, int m){",
						"  vi L(2*n), E(2*n), H(n, -1);",
						"  vb visited(n, false);",
						"  int idx = 0;",
						"  dfs(0, 0, adjMatrix, visited, L, E, H, p, idx);",
						"  //LCA(i, j) é o E[ indice do min( L(H[i]...H[j]) ) ]. Para isto usamos uma SegTree ou SparseTable em L (E[SpT.query(H[i], H[j])])",
						"  SparseTable Spt = SparseTable(L);",
						"  int a, b;",
						"  for (int i = 0; i < m; i++){",
						"    cin>>a>>b;",
						"    a--;b--;",
						"    int lca = E[Spt.RMQ(min(H[a], H[b]), max(H[a], H[b]))];",
						"  }",
						"}"
		],
		"description":"Encontra o vertice mais próximo acima dos 2 vértices selecionados"
	},
	"KruskalMST":{
		"prefix":["Kruskal", "MST"],
		"body":["//Cada valor começa por ser o seu proprio set",
						"void makeSet(int v, vi &parent) {",
						"\tparent[v] = v;",
						"}",
						"int findSet(int v, vi &parent) {",
						"\tif (v != parent[v]) parent[v] = findSet(parent[v], parent);",
						"\treturn parent[v];",
						"}",
						"void unionSets(int u, int v, vi &parent) {",
						"\tint root1 = findSet(u, parent);",
						"\tint root2 = findSet(v, parent);",
						"\tparent[root2] = root1;",
						"}",
						"bool check(int u, int v, vi &parent) {",
						"\treturn findSet(u, parent) == findSet(v, parent);",
						"}",
						"",
						"template<class T> T KruskalMST(vector<tuple<T, int, int>> edges, int V){",
						"\tsort(all(edges));",
						"\tvi parent(V);",
						"\tfor (int i = 0; i < V; i++){",
						"\t\tmakeSet(i, parent);",
						"\t}",
						"\tT mst_cost = 0, num_taken = 0;",
						"\tfor (auto &[w, u, v]: edges){",
						"\t\tif (check(u, v, parent)) continue;",
						"\t\tmst_cost += w;",
						"\t\tunionSets(u, v, parent);",
						"\t\t++num_taken;",
						"\t\tif (num_taken == V-1) break;",
						"\t}",
						"\treturn mst_cost;",
						"}"
		],
		"description":"Algoritmo que calcula a Minimum Spanning Tree. MST é a menor arvore de um grafo que conecta todos os seus vertices"
	}
}
