{
	"Aho-Corasick":{
		"prefix":"Aho-Corasick",
		"body":["string text;    //Text",
			"int n;          //Size of text,",
			"int k;          //Number of keys",
			"int maxs = 0;   // Should be equal to the sum of the length of all keywords.",
			"int maxc = 26; // Maximum number of characters in input alphabet\n",
			"// Returns the number of states that the built machine has.",
			"// States are numbered 0 up to the return value - 1, inclusive .",
			"int buildMatchingMachine(string arr[], int k, vector<map<int, bool>> &out, vi &f, vv &g){",
			"\tint states = 1;",
			"\tfor ( int i = 0; i < k; ++i){ // Construct values for goto function, i .e ., fill g",
			"\t\tconst string &word = arr[i];",
			"\t\tint currentState = 0;",
			"\t\tfor ( int j = 0; j < (int) word.size(); ++j){",
			"\t\t\tint ch = word[j]-'a';",
			"\t\t\tif (g[currentState][ch] == -1){ // Allocate a new node (create a new state) if a node for ch doesnt exist .",
			"\t\t\t\tg[currentState][ch] = states++;",
			"\t\t\t}",
			"\t\t\tcurrentState = g[currentState][ch];",
			"\t\t}",
			"\t\tout[currentState][i] = true; // Add current word in output function",
			"\t}",
			"\tfor ( int ch = 0; ch < maxc; ++ch){",
			"\t\tif (g[0][ch] == -1){",
			"\t\t\tg[0][ch] = 0;",
			"\t\t}",
			"\t}",
			"\tqueue<int> q;",
			"\tfor ( int ch = 0; ch < maxc; ++ch){",
			"\t\tif (g[0][ch] != 0){",
			"\t\t\tf [g[0][ch]] = 0;",
			"\t\t\tq.push(g[0][ch]) ;",
			"\t\t}",
			"\t}",
			"\twhile (q.size () ) {",
			"\t\tint state = q.front () ;",
			"\t\tq.pop();",
			"\t\tfor ( int ch = 0; ch < maxc; ++ch){",
			"\t\t\tif (g[state][ch] != -1){",
			"\t\t\t\tint failure = f [state];",
			"\t\t\t\twhile (g[ failure][ch] == -1){ // Find the deepest node labeled by proper suffix of string from root to current state .",
			"\t\t\t\t\tfailure = f [ failure ];",
			"\t\t\t\t}",
			"\t\t\t\tfailure = g[failure][ch];",
			"\t\t\t\tf [g[state][ch]] = failure ;",
			"\t\t\t\tfor (pair<int, bool> par: out[failure]){",
			"\t\t\t\t\tout[g[state][ch]][par.fi] = par.se;",
			"\t\t\t\t}",
			"\t\t\t\tq.push(g[state][ch]) ;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn states ;",
			"}\n",
			"int findNextState(int currentState, char nextInput, vector<map<int, bool>> &out, vi &f, vv &g){ //Returns the next state the machine will transition to using goto and failure functions.",
			"\tint answer = currentState;",
			"\tint ch = nextInput -'a';",
			"\twhile (g[answer][ch] == -1){",
			"\t\tanswer = f[answer];",
			"\t}",
			"\treturn g[answer][ch];",
			"}\n",
			"void searchWords(string arr[], int k, string text, vector<map<int, bool>> &out, vi &f, vv &g, vv &ocor, vi &tam) {",
			"\tbuildMatchingMachine(arr, k, out, f, g); // Build machine with goto, failure and output functions",
			"\tint currentState = 0;",
			"\tfor ( int i = 0; i < (int) text.size() ; ++i){",
			"\t\tcurrentState = findNextState(currentState, text[i], out, f, g) ;",
			"\t\t/*if (out[currentState] == 0){ // If match not found, move to next state, uncomment if number of keys is less of 64",
			"\t\t\tcontinue;",
			"\t\t}*/",
			"\t\tfor (pair<int, bool> par: out[currentState]){ // Match found, print all matching words of arr[]",
			"\t\t\tocor[i-tam[par.fi]+1].pb(par.fi);",
			"\t\t}",
			"\t}",
			"}\n",
			"void solve(){",
			"\tcin>>text;",
			"\tn = (int) text.size();",
			"\tvv ocor(n);                     //To store the index where each key starts in texts",
			"\tcin>>k;",
			"\tstring arr[k];                  //Stores every key",
			"\tvi tam(k);                      //Stores every key size",
			"\tfor (int j = 0; j < k; j++){",
			"\t\tcin>>arr[j];",
			"\t\ttam[j] = arr[j].size();",
			"\t\tmaxs += tam[j];",
			"\t}",
			"\tvector<map<int, bool>> out(maxs);                       // Stores the word number for each state (letter in text)",
			"\t//vi out(maxs, 0);                                      // Bit i in this mask is one if the word with index i in that state. To use if there are less than 64 keys",
			"\tvi f (maxs, -1);                                        // FAILURE FUNCTION IS IMPLEMENTED USING f[]",
			"\tvv g (maxs, vi(maxc, -1));                              // GOTO FUNCTION (OR TRIE) IS IMPLEMENTED USING g[][]",
			"\tsearchWords(arr, k, text, out, f, g, ocor, tam);        // Each state (char in text) has the key numbers of the keys that start in that state in ocor  ",
			"\treturn;",
			"}\n"
		],
		"description":"Find where (start) keys are in a text"
	},

	"Knuth-Morris-Pratt":{
		"prefix":"KMP",
		"body":["string T, P;                    // T = text, P = pattern",
			"int n, m;                       // n = |T|, m = |P|\n",
			"void kmpPreprocess(vi &b) {                         // call this first",
			"\tint i = 0, j = -1; b[0] = -1;                   // starting values",
			"\twhile (i < m) {                                 // pre-process P",
			"\twhile ((j >= 0) && (P[i] != P[j])) j = b[j];    // different, reset j",
			"\t\t++i; ++j;                                   // same, advance both",
			"\t\tb[i] = j;",
			"\t}",
			"}\n",
			"void kmpSearch(vi &b) {                             // similar as above",
			"\tint i = 0, j = 0;                               // starting values",
			"\twhile (i < n) {                                 // search through T",
			"\twhile ((j >= 0) && (T[i] != P[j])) j = b[j];    // if different, reset j",
			"\t\t++i; ++j;                                   // if same, advance both",
			"\t\tif (j == m) {                               // a match is found",
			"\t\t\tprintf(\"P is found at index %d in T\\n\", i-j);",
			"\t\t\tj = b[j];                               // prepare j for the next",
			"\t\t}",
			"\t}",
			"}\n",
			"void solve(){",
			"\tcin>>T;",
			"\tcin>>P;",
			"\tn = (int) T.size();",
			"\tm = (int) P.size();",
			"\tvi b(m+1);                // b = back table",
			"\tkmpPreprocess(b);",
			"\tkmpSearch(b);",
			"}"
		],
		"description":"Find ocorrences os P in T"
	},
	"Longest Common Subsequence":{
		"prefix":"LCS",
		"body":["int LCS(string a, string b, int tamA, int tamB){",
						"\tvv bu(tamA + 2, vi(tamB, 0));",
						"\tfor (int i = 1; i <= tamA; i++){",
						"\t\tfor (int j = 1; j <= tamB; j++){",
						"\t\t\tif (a[i-1] == b[j-1]) bu[i][j] = bu[i-1][j-1] + 1;",
						"\t\t\telse bu[i][j] = max(bu[i-1][j], bu[i][j-1]);",
						"\t\t}",
						"\t}",
						"\treturn bu[tamA][tamB];",
						"}"
		],
		"description":"tamanho da maior subsequecia comum as duas palavras (nao necessariamente continua)"
	}
}
