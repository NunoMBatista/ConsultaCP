{
	"Order Statistic Tree Map":{
		"prefix":"OSTmap",
		"body":["#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"using omap = tree<int,         // key type",
			"\t\tint,         // value type",
			"\t\tless<int>,   // compare function",
			"\t\trb_tree_tag,",
			"\t\ttree_order_statistics_node_update>;",
			"auto m = omap();"
		],
		"description":"Map de valores organizados numa árvore. Só procurar valores existentes"
	},
	"Order Statistic Tree Set":{
		"prefix":"OSTset",
		"body":["#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"using oset = tree<int,         // key type",
			"\t\tnull_type,   // value type",
			"\t\tless<int>,   // compare function",
			"\t\trb_tree_tag,",
			"\t\ttree_order_statistics_node_update>;",
			"auto s = oset();"
		],
		"description":"Set de valores organizador numa árvore. Só procurar valores existentes"
	},
	"Disjoint Set Union": {
		"prefix": "DSU",
		"body":["//Cada valor começa por ser o seu proprio set",
			"void makeSet(int v, vi &parent) {",
			"\tparent[v] = v;",
			"}",
			"int findSet(int v, vi &parent) {",
			"\tif (v != parent[v])",
			"\tparent[v] = findSet(parent[v], parent);",
			"\treturn parent[v];",
			"}",
			"void unionSets(int u, int v, vi &parent) {",
			"\tint root1 = findSet(u, parent);",
			"\tint root2 = findSet(v, parent);",
			"\tparent[root2] = root1;",
			"}",
			"bool check(int u, int v, vi &parent) {",
			"\treturn findSet(u, parent) == findSet(v, parent);",
			"}"
		],
		"description":"Disjoint Set Union: juntar árvores (quando só importa em que árvore está o vértice e não a ligação a que vértice)"
	},
	"Trie":{
		"prefix": "trie",
		"body": [
			"template<char MIN_CHAR = 'a', int ALPHABET = 26>",
			"struct array_trie {",
			"    struct trie_node {",
			"        array<int, ALPHABET> child;",
			"        int words_here = 0, starting_with = 0;",
			"",
			"        trie_node() {",
			"            memset(&child[0], -1, ALPHABET * sizeof(int));",
			"        }",
			"    };",
			"",
			"    static const int ROOT = 0;",
			"",
			"    vector<trie_node> nodes = {trie_node()};",
			"",
			"    array_trie(int total_length = -1) {",
			"        if (total_length >= 0)",
			"            nodes.reserve(total_length + 1);",
			"    }",
			"",
			"    int get_or_create_child(int node, int c) {",
			"        if (nodes[node].child[c] < 0) {",
			"            nodes[node].child[c] = int(nodes.size());",
			"            nodes.emplace_back();",
			"        }",
			"        return nodes[node].child[c];",
			"    }",
			"",
			"    int build(const string &word, int delta) {",
			"        int node = ROOT;",
			"        for (char ch : word) {",
			"            nodes[node].starting_with += delta;",
			"            node = get_or_create_child(node, ch - MIN_CHAR);",
			"        }",
			"        nodes[node].starting_with += delta;",
			"        return node;",
			"    }",
			"",
			"    int add(const string &word) {",
			"        int node = build(word, +1);",
			"        nodes[node].words_here++;",
			"        return node;",
			"    }",
			"",
			"    int erase(const string &word) {",
			"        int node = build(word, -1);",
			"        nodes[node].words_here--;",
			"        return node;",
			"    }",
			"",
			"    int find(const string &str) const {",
			"        int node = ROOT;",
			"        for (char ch : str) {",
			"            node = nodes[node].child[ch - MIN_CHAR];",
			"            if (node < 0)",
			"                break;",
			"        }",
			"        return node;",
			"    }",
			"",
			"    int count_prefixes(const string &str, bool include_full) const {",
			"        int node = ROOT, count = 0;",
			"        for (char ch : str) {",
			"            count += nodes[node].words_here;",
			"            node = nodes[node].child[ch - MIN_CHAR];",
			"            if (node < 0)",
			"                break;",
			"        }",
			"        if (include_full && node >= 0)",
			"            count += nodes[node].words_here;",
			"        return count;",
			"    }",
			"",
			"    int count_starting_with(const string &str, bool include_full) const {",
			"        int node = find(str);",
			"        if (node < 0)",
			"            return 0;",
			"        return nodes[node].starting_with - (include_full ? 0 : nodes[node].words_here);",
			"    }",
			"};"
		],
		"description": "Coloca palavras numa tree de chars"
	},
	"Segment Trees":{
		"prefix": "segtree", 
		"body": ["#define op(l, r) (l + r)\t\t//operação da segment tree",
			"#define DEFAULTVALUE 0;",
			"const ll inf = 1e9;",
			"struct Node {",
			"    Node *l = 0, *r = 0;",
			"    ll lo, hi, mset = inf, madd = 0, val = -inf;",
			"    Node(ll lo,ll hi):lo(lo),hi(hi){} // Large interval of -inf",
			"    Node(vector<int>& v, ll lo, ll hi) : lo(lo), hi(hi) {",
			"        if (lo + 1 < hi) {",
			"            ll mid = lo + (hi - lo)/2;",
			"            l = new Node(v, lo, mid);", 
			"            r = new Node(v, mid, hi);",
			"            val = op(l->val, r->val);",
			"        }",
			"        else val = v[lo];",
			"    }",
			"    ll query(ll L, ll R) {",
			"        if (R <= lo || hi <= L) return 0;",
			"        if (L <= lo && hi <= R) return val;",
			"        push();",
			"        return op(l->query(L, R), r->query(L, R));",
			"    }",
			"    void set(ll L, ll R, ll x) {",
			"        if (R <= lo || hi <= L) return;",
			"        if (L <= lo && hi <= R) mset = val = x, madd = 0;",
			"        else {",
			"            push(), l->set(L, R, x), r->set(L, R, x);",
			"            val = op(l->val, r->val);",
			"        }",
			"    }",
			"    void add(ll L, ll R, ll x) {",
			"        if (R <= lo || hi <= L) return;",
			"        if (L <= lo && hi <= R) {",
			"            if (mset != inf) mset += x;",
			"            else madd += x;",
			"            val += x;",
			"        }",
			"        else {",
			"            push(), l->add(L, R, x), r->add(L, R, x);",
			"            val = op(l->val, r->val);",
			"        }",
			"    }",
			"    void push() {",
			"        if (!l) {",
			"            ll mid = lo + (hi - lo)/2;",
			"            l = new Node(lo, mid); r = new Node(mid, hi);",
			"        }",
			"        if (mset != inf)",
			"            l->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;",
			"        else if (madd)",
			"            l->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;",
			"    }",
			"};"
		],
		"description": "Segment tree (fazer soma, max, min, multiplicações, or, and, xor, ... (operações associativas) em subarrays de arrays"
	},
	"Persistent Tries":{
		"prefix":"PerTrie",
		"body":["// Node for lowercase strings",
			"struct Node {",
			"\tarray<shared_ptr<Node>, 26> children;",
			"\tbool end;     // whether this node represents the end of a key",
			"\tsize_t count; // optional (depending on queries)\n",
			"\tNode() : children{}, end{false}, count{0}  {}",
			"};\n",
			"class Trie {",
			"private:",
			"\tshared_ptr<Node> root;",
			"\texplicit Trie(shared_ptr<Node> root) : root(root) {}\n",	
			"public:",
			"\tTrie() : root(new Node()) {}",
			"\tsize_t size() const {",
			"\treturn root->count;",
			"\t}\n",
			"\tbool exists(string_view s) const {",
			"\t\tauto node = root;",
			"\t\tfor (auto c : s) {",
			"\t\t\tauto idx = c - 'a';",
			"\t\t\tif (node->children[idx]) {",
			"\t\t\t\tnode = node->children[idx];",
			"\t\t\t} else {",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn node->end;",
			"\t}\n",
			"\toptional<Trie> insert(string_view s) {",
			"\t\tif (exists(s)) {",
			"\t\t\treturn {};",
			"\t\t}\n",
			"\t\tauto nroot = make_shared<Node>(*root);",
			"\t\tauto node = nroot;",
			"\t\tnode->count += 1;",
			"\t\tfor (auto c : s) {",
			"\t\t\tauto idx = c - 'a';",
			"\t\t\tif (node->children[idx]) {",
			"\t\t\t\tnode = node->children[idx] = make_shared<Node>(*(node->children[idx]));",
			"\t\t\t} else {",
			"\t\t\t\tnode = node->children[idx] = make_shared<Node>();",
			"\t\t\t}",
			"\t\t\tnode->count += 1;",
			"\t\t}",
			"\t\tnode->end = true;",
			"\t\treturn Trie(nroot);",
			"\t}\n",
			"\tsize_t count(string_view prefix) const {",
			"\t\tauto node = root.get();",
			"\t\tfor (auto c : prefix) {",
			"\t\t\tauto idx = c - 'a';",
			"\t\t\tif (node->children[idx]) {",
			"\t\t\t\tnode = node->children[idx].get();",
			"\t\t\t} else {",
			"\t\t\t\treturn 0;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn node->count;",
			"\t}",
			"};"
		],
		"description":"Trie que guarda alterações feitas a ela. Guardar uma nova trie a cada alteração que se faz"
	},
	"Persistent Segment Trees":{
		"prefix":"PerSegTree",
		"body":["struct Node{ int mn, l, r; };\n",
			"int init(int l, int r, Node st[], int* curr){",
			"\tif (l == r){ st[++(*curr)].mn = INF; return (*curr); }",
			"\tint m = l+(r-l)/2;",
			"\tint p = ++(*curr);",
			"\tst[p] = {0, init(l, m, st, curr), init(m+1, r, st, curr)};",
			"\tst[p].mn = min(st[st[p].l].mn, st[st[p].r].mn);",
			"\treturn p;",
			"}\n",
			"int update(int i, int l, int r, int k, int x, Node st[], int* curr){",
			"\tif (l == r){ st[++(*curr)].mn = x; return *curr; }",
			"\tint m = l+(r-l)/2;",
			"\tint p = ++(*curr);",
			"\tif (k <= m){",
			"\t\tst[p] = {0, update(st[i].l, l, m, k, x, st, curr), st[i].r};",
			"\t} else {",
			"\t\tst[p] = {0, st[i].l, update(st[i].r, m+1, r, k, x, st, curr)};",
			"\t}",
			"\tst[p].mn = min(st[st[p].l].mn, st[st[p].r].mn);",
			"\treturn p;",
			"}\n",
			"int query(int i, int l, int r, int tl, int tr, Node st[]){",
			"\tif (l > tr || r < tl) return INF;",
			"\tif (tl <= l && r <= tr) return st[i].mn;",
			"\tint m = l+(r-l)/2;",
			"\treturn min(query(st[i].l, l, m, tl, tr, st), query(st[i].r, m+1, r, tl, tr, st));",
			"}\n",
			"int arr[n+1], root[n+2], curr = 1;\t\t\t\t//Tres linhas seguintes por no solve",
			"map<int, int> pos;",
			"Node st[22*n];"
		],
		"description":"Serve para calcular e fazer queries sobre range sum em log(n) e atualizar a segtree em parte estritamente necessárias (poupa tempo e espaço)"
	},
	"Sparse Table":{
		"prefix":["SpT", "SparseTable"],
		"body":["class SparseTable{",
						"  private:",
						"    vi A, P2, L2;             //A -> o array, P2 -> P2[x] = 2^x, L2 -> L2[x] = floor(log2(x))",
						"    vv SpT;",
						"  public:",
						"    SparseTable(){}\n",
						"    SparseTable(vi &initialA){",
						"      A = initialA;",
						"      int n = (int) A.size();",
						"      int L2_n = (int) log2(n)+1;",
						"      P2.assign(L2_n+1, 0);",
						"      L2.assign((1<<L2_n)+1, 0);",
						"      for (int i = 0; i <= L2_n; i++){",
						"        P2[i] = (1<<i);",
						"        L2[(1<<i)] = i;",
						"      }",
						"      for (int i = 2; i < P2[L2_n]; i++){",
						"        if (L2[i] == 0) L2[i] = L2[i-1];",
						"      }\n",
						"      // the initialization phase",
						"      SpT = vv (L2[n]+1, vi(n));",
						"      for (int j = 0; j < n; j++){",
						"        SpT[0][j] = j;",
						"      }\n",
						"      //the two nested loops below have overall time complexity = O(n log(n))",
						"      for (int i = 1; P2[i] <= n; i++){",
						"        for (int j = 0; j+P2[i]-1 < n; j++){",
						"          int x = SpT[i-1][j];",
						"          int y = SpT[i-1][j+P2[i-1]];",
						"          SpT[i][j] = A[x] <= A[y] ? x : y;",
						"        }",
						"      }",
						"    }",
						"    ",
						"    int RMQ(int i, int j){",
						"      int k = L2[j-i+1];",
						"      int x = SpT[k][i];",
						"      int y = SpT[k][j-P2[k]+1];",
						"      return A[x] <= A[y] ? x : y;",
						"    }",
						"};",
						"",
						"//Dentro de solve ou main",
						"SparseTable Spt = SparseTable(L);"
			],
	"description":"Faz range queries em tempo constante, sendo a sua construção mais complexa que SegTree e array a ser procurado nunca pode ser alterado"
	},
  "Fenwick Tree":{
				"prefix":["FenwickTree", "BIT"],
				"body":["int m;",
								"ll ft[5000010];       //tamMax+1 > m",
								"//ll ftAux[5000001];",
								"",
								"//Fazer build às ft's necessárias (ftAux só no caso de RURQ)",
								"void build(ll* v){",
								"  for (int i = 0; i <= m; i++){",
								"    v[i] = 0;",
								"  }",
								"}",
								"",
								"void build(ll* v, const vll &f){      //Recebe array com frequencias de valores",
								"  for (int i = 0; i <= m; i++){",
								"    v[i] = f[i];",
								"    if (i + (i & -(i)) <= m){",
								"      v[i + (i & -(i))] += v[i];",
								"    }",
								"  }",
								"}",
								"",
								"void build(ll *v, const vi &s){      //Recebe array dos valores por contar",
								"  vll f(m+1, 0);",
								"  for (int i = 0; i < (int)s.size(); i++){",
								"    ++f[s[i]];",
								"  }",
								"  build(v, f);",
								"}",
								"",
								"//Operações a usar em caso de PURQ e PUPQ, usar apenas ft",
								"ll rsq(ll *v, int j){",
								"  ll sum = 0;",
								"  for(; j; j -= (j & -(j))){",
								"    sum += v[j];",
								"  }",
								"  return sum;",
								"}",
								"",
								"ll rsq(ll *v, int i, int j){ return rsq(v, j) - rsq(v, i-1); } //inc/exclusion",
								"",
								"void update(ll *fv, int i, ll v){",
								"  for (; i < m; i += (i & -(i))){",
								"    fv[i] += v;",
								"  }",
								"}",
								"",
								"//Qual prefix sum tem o valor k",
								"int select(ll* v, ll k){",
								"  int p = 1;",
								"  while (p*2 < m) p *= 2;",
								"  int i = 0;",
								"  while (p) {",
								"    if (k > v[i+p]) {",
								"      k -= v[i+p];",
								"      i += p;",
								"    }",
								"    p /= 2;",
								"  }",
								"  return i+1;",
								"}",
								"",
								"//Operações a usar em caso de RUPQ, usar apenas ft",
								"void range_update(ll *fv, int ui, int uj, ll v){",
								"  update(fv, ui, v);",
								"  update(fv, uj+1, -v);",
								"}",
								"",
								"ll point_query(ll *v, int i) { return rsq(v, i); }",
								"",
								"//Operações a usar em caso de RURQ, usar ft e ftaux",
								"void range_update(ll *fv, ll *vaux, int ui, int uj, ll v){",
								"  range_update(fv, ui, uj, v);",
								"  update(vaux, ui, v*(ui-1));",
								"  update(vaux, uj+1, -v*(uj));",
								"}",
								"ll rsq(ll *v, ll*vaux, int j){",
								"  return point_query(v, j)*j - rsq(vaux, j);",
								"}",
								"",
								"ll rsq(ll *v, ll *vaux, int i, int j) { return rsq(v, vaux, j) - rsq(v, vaux, i-1); }"
				],
				"description":"RSQ para prefix array (kinda)"
		}
}
