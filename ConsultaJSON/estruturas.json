{
	"Order Statistic Tree Map":{
		"prefix":"OSTmap",
		"body":["#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"using omap = tree<int,         // key type",
			"\t\tint,         // value type",
			"\t\tless<int>,   // compare function",
			"\t\trb_tree_tag,",
			"\t\ttree_order_statistics_node_update>;",
			"auto m = omap();"
		],
		"description":"Map de valores organizados numa árvore. Só procurar valores existentes"
	},
	"Order Statistic Tree Set":{
		"prefix":"OSTset",
		"body":["#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"using oset = tree<int,         // key type",
			"\t\tnull_type,   // value type",
			"\t\tless<int>,   // compare function",
			"\t\trb_tree_tag,",
			"\t\ttree_order_statistics_node_update>;",
			"auto s = oset();"
		],
		"description":"Set de valores organizador numa árvore. Só procurar valores existentes"
	},
	"Trie":{
		"prefix": "trie",
		"body": [
			"template<char MIN_CHAR = 'a', int ALPHABET = 26>",
			"struct array_trie {",
			"    struct trie_node {",
			"        array<int, ALPHABET> child;",
			"        int words_here = 0, starting_with = 0;",
			"",
			"        trie_node() {",
			"            memset(&child[0], -1, ALPHABET * sizeof(int));",
			"        }",
			"    };",
			"",
			"    static const int ROOT = 0;",
			"",
			"    vector<trie_node> nodes = {trie_node()};",
			"",
			"    array_trie(int total_length = -1) {",
			"        if (total_length >= 0)",
			"            nodes.reserve(total_length + 1);",
			"    }",
			"",
			"    int get_or_create_child(int node, int c) {",
			"        if (nodes[node].child[c] < 0) {",
			"            nodes[node].child[c] = int(nodes.size());",
			"            nodes.emplace_back();",
			"        }",
			"        return nodes[node].child[c];",
			"    }",
			"",
			"    int build(const string &word, int delta) {",
			"        int node = ROOT;",
			"        for (char ch : word) {",
			"            nodes[node].starting_with += delta;",
			"            node = get_or_create_child(node, ch - MIN_CHAR);",
			"        }",
			"        nodes[node].starting_with += delta;",
			"        return node;",
			"    }",
			"",
			"    int add(const string &word) {",
			"        int node = build(word, +1);",
			"        nodes[node].words_here++;",
			"        return node;",
			"    }",
			"",
			"    int erase(const string &word) {",
			"        int node = build(word, -1);",
			"        nodes[node].words_here--;",
			"        return node;",
			"    }",
			"",
			"    int find(const string &str) const {",
			"        int node = ROOT;",
			"        for (char ch : str) {",
			"            node = nodes[node].child[ch - MIN_CHAR];",
			"            if (node < 0)",
			"                break;",
			"        }",
			"        return node;",
			"    }",
			"",
			"    int count_prefixes(const string &str, bool include_full) const {",
			"        int node = ROOT, count = 0;",
			"        for (char ch : str) {",
			"            count += nodes[node].words_here;",
			"            node = nodes[node].child[ch - MIN_CHAR];",
			"            if (node < 0)",
			"                break;",
			"        }",
			"        if (include_full && node >= 0)",
			"            count += nodes[node].words_here;",
			"        return count;",
			"    }",
			"",
			"    int count_starting_with(const string &str, bool include_full) const {",
			"        int node = find(str);",
			"        if (node < 0)",
			"            return 0;",
			"        return nodes[node].starting_with - (include_full ? 0 : nodes[node].words_here);",
			"    }",
			"};"
		],
		"description": "Coloca palavras numa tree de chars"
	},
	"Segment Trees":{
		"prefix": "segtree", 
		"body": ["#define op(l, r) (l + r)\t\t//operação da segment tree",
			"#define DEFAULTVALUE 0;",
			"const ll inf = 1e9;",
			"struct Node {",
			"    Node *l = 0, *r = 0;",
			"    ll lo, hi, mset = inf, madd = 0, val = -inf;",
			"    Node(ll lo,ll hi):lo(lo),hi(hi){} // Large interval of -inf",
			"    Node(vector<int>& v, ll lo, ll hi) : lo(lo), hi(hi) {",
			"        if (lo + 1 < hi) {",
			"            ll mid = lo + (hi - lo)/2;",
			"            l = new Node(v, lo, mid);", 
			"            r = new Node(v, mid, hi);",
			"            val = op(l->val, r->val);",
			"        }",
			"        else val = v[lo];",
			"    }",
			"    ll query(ll L, ll R) {",
			"        if (R <= lo || hi <= L) return 0;",
			"        if (L <= lo && hi <= R) return val;",
			"        push();",
			"        return op(l->query(L, R), r->query(L, R));",
			"    }",
			"    void set(ll L, ll R, ll x) {",
			"        if (R <= lo || hi <= L) return;",
			"        if (L <= lo && hi <= R) mset = val = x, madd = 0;",
			"        else {",
			"            push(), l->set(L, R, x), r->set(L, R, x);",
			"            val = op(l->val, r->val);",
			"        }",
			"    }",
			"    void add(ll L, ll R, ll x) {",
			"        if (R <= lo || hi <= L) return;",
			"        if (L <= lo && hi <= R) {",
			"            if (mset != inf) mset += x;",
			"            else madd += x;",
			"            val += x;",
			"        }",
			"        else {",
			"            push(), l->add(L, R, x), r->add(L, R, x);",
			"            val = op(l->val, r->val);",
			"        }",
			"    }",
			"    void push() {",
			"        if (!l) {",
			"            ll mid = lo + (hi - lo)/2;",
			"            l = new Node(lo, mid); r = new Node(mid, hi);",
			"        }",
			"        if (mset != inf)",
			"            l->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;",
			"        else if (madd)",
			"            l->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;",
			"    }",
			"};"
		],
		"description": "Segment tree (fazer soma, max, min, multiplicações, or, and, xor, ... (operações associativas) em subarrays de arrays"
	},
	"Persistent Tries":{
		"prefix":"PerTrie",
		"body":["// Node for lowercase strings",
			"struct Node {",
			"\tarray<shared_ptr<Node>, 26> children;",
			"\tbool end;     // whether this node represents the end of a key",
			"\tsize_t count; // optional (depending on queries)\n",
			"\tNode() : children{}, end{false}, count{0}  {}",
			"};\n",
			"class Trie {",
			"private:",
			"\tshared_ptr<Node> root;",
			"\texplicit Trie(shared_ptr<Node> root) : root(root) {}\n",	
			"public:",
			"\tTrie() : root(new Node()) {}",
			"\tsize_t size() const {",
			"\treturn root->count;",
			"\t}\n",
			"\tbool exists(string_view s) const {",
			"\t\tauto node = root;",
			"\t\tfor (auto c : s) {",
			"\t\t\tauto idx = c - 'a';",
			"\t\t\tif (node->children[idx]) {",
			"\t\t\t\tnode = node->children[idx];",
			"\t\t\t} else {",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn node->end;",
			"\t}\n",
			"\toptional<Trie> insert(string_view s) {",
			"\t\tif (exists(s)) {",
			"\t\t\treturn {};",
			"\t\t}\n",
			"\t\tauto nroot = make_shared<Node>(*root);",
			"\t\tauto node = nroot;",
			"\t\tnode->count += 1;",
			"\t\tfor (auto c : s) {",
			"\t\t\tauto idx = c - 'a';",
			"\t\t\tif (node->children[idx]) {",
			"\t\t\t\tnode = node->children[idx] = make_shared<Node>(*(node->children[idx]));",
			"\t\t\t} else {",
			"\t\t\t\tnode = node->children[idx] = make_shared<Node>();",
			"\t\t\t}",
			"\t\t\tnode->count += 1;",
			"\t\t}",
			"\t\tnode->end = true;",
			"\t\treturn Trie(nroot);",
			"\t}\n",
			"\tsize_t count(string_view prefix) const {",
			"\t\tauto node = root.get();",
			"\t\tfor (auto c : prefix) {",
			"\t\t\tauto idx = c - 'a';",
			"\t\t\tif (node->children[idx]) {",
			"\t\t\t\tnode = node->children[idx].get();",
			"\t\t\t} else {",
			"\t\t\t\treturn 0;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn node->count;",
			"\t}",
			"};"
		],
		"description":"Trie que guarda alterações feitas a ela. Guardar uma nova trie a cada alteração que se faz"
	},
	"Persistent Segment Trees":{
		"prefix":"PerSegTree",
		"body":["struct Node{ int mn, l, r; };\n",
			"int init(int l, int r, Node st[], int* curr){",
			"\tif (l == r){ st[++(*curr)].mn = INF; return (*curr); }",
			"\tint m = l+(r-l)/2;",
			"\tint p = ++(*curr);",
			"\tst[p] = {0, init(l, m, st, curr), init(m+1, r, st, curr)};",
			"\tst[p].mn = min(st[st[p].l].mn, st[st[p].r].mn);",
			"\treturn p;",
			"}\n",
			"int update(int i, int l, int r, int k, int x, Node st[], int* curr){",
			"\tif (l == r){ st[++(*curr)].mn = x; return *curr; }",
			"\tint m = l+(r-l)/2;",
			"\tint p = ++(*curr);",
			"\tif (k <= m){",
			"\t\tst[p] = {0, update(st[i].l, l, m, k, x, st, curr), st[i].r};",
			"\t} else {",
			"\t\tst[p] = {0, st[i].l, update(st[i].r, m+1, r, k, x, st, curr)};",
			"\t}",
			"\tst[p].mn = min(st[st[p].l].mn, st[st[p].r].mn);",
			"\treturn p;",
			"}\n",
			"int query(int i, int l, int r, int tl, int tr, Node st[]){",
			"\tif (l > tr || r < tl) return INF;",
			"\tif (tl <= l && r <= tr) return st[i].mn;",
			"\tint m = l+(r-l)/2;",
			"\treturn min(query(st[i].l, l, m, tl, tr, st), query(st[i].r, m+1, r, tl, tr, st));",
			"}\n",
			"int arr[n+1], root[n+2], curr = 1;\t\t\t\t//Tres linhas seguintes por no solve",
			"map<int, int> pos;",
			"Node st[22*n];"
		],
		"description":"Serve para calcular e fazer queries sobre range sum em log(n) e atualizar a segtree em parte estritamente necessárias (poupa tempo e espaço)"
	}
}
