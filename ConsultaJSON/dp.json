{
	"Longest Increasing Sub-sequence":{
		"prefix":"LIS",
		"body":["void printLIS(int i, vi &p, vi &arr){       //imprime LIS, sabendo o ultimo indice",
			"\tif (p[i] == -1){",
			"\t\tcout<<arr[i];",
			"\t\treturn;",
			"\t}",
			"\tprintLIS(p[i], p, arr);",
			"\tcout<<' '<<arr[i];",
			"}\n",
			"pii LIS(int n, vi &p, vi &arr){     //retorna maior LIS e o ultimo indice do maior LIS",
			"\tint k= 0, lis_end = 0;",
			"\tvi L(n, 0), L_id(n, 0);",
			"\tp.assign(n, -1);\n",
			"\tfor (int i = 0; i < n; i++){",
			"\t\tint pos = lower_bound(L.begin(), L.begin() + k, arr[i]) - L.begin();",
			"\t\tL[pos] = arr[i];",
			"\t\tL_id[pos] = i;",
			"\t\tp[i] = pos ? L_id[pos-1]:-1;",
			"\t\tif (pos == k){",
			"\t\t\tk = pos + 1;",
			"\t\t\tlis_end = i;",
			"\t\t}",
			"\t}",
			"\treturn mp(k, lis_end);",
			"}"
		],
		"description":"Maior sequencia crescente num array"
	},
	"Coin Change BU":{
		"prefix":"CoinChangeBU",
		"body":["int CoinChangeBU(int nMoe, int troco, vi &moedas){",
			"\tvv trocos(nMoe+1, vi(troco+1, -1));",
			"\tfor (int j = 0; j < troco+1; j++){",
			"\t\ttrocos[0][j] = 0;",
			"\t}",
			"\tfor (int j = 0; j <= nMoe; j++){",
			"\t\ttrocos[j][0] = 1;",
			"\t}",
			"\tfor (int j = 1; j <= nMoe; j++){",
			"\t\tfor (int k = 1; k <= troco; k++){",
			"\t\t\tif (k < moedas[j-1]){",
			"\t\t\t\ttrocos[j][k] = trocos[j-1][k];",
			"\t\t\t}else{",
			"\t\t\t\ttrocos[j][k] = trocos[j-1][k] + trocos[j][k - moedas[j-1]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn trocos[nMoe][troco];",
			"}"],
		"description":"Formas (sem repetição) de dar trocos com n Moedas, diferentes e infinitas"
	},
	"Coin Change Permutação":{
		"prefix": "CoinChange1D",
		"body":["int CoinChange1D(vi &moedas, int troco){",
			"\tvi trocos(troco + 1, 0);",
			"\ttrocos[0] = 1;",
			"\tfor (int j = 1; j <= troco; j++){",
			"\t\tfor (int coin: moedas){",
			"\t\t\tif (j - coin >= 0){",
			"\t\t\t\ttrocos[j] = (trocos[j] + trocos[j-coin])%MOD;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn trocos[troco]%MOD;",
			"}"],
		"description": "Number of permutations of coins that, when summed, are troco"
	},
	"Least Coins needed":{
		"prefix":"LeastCoins",
		"body":["int LeastCoins(vi &moedas, int troco){",
			"\tvi trocos(troco + 1, INF);",
			"\ttrocos[0] = 0;",
			"\tfor (int j = 1; j <= troco; j++){",
			"\t\tfor (int coin: moedas){",
			"\t\t\tif (j - coin >= 0){",
			"\t\t\t\ttrocos[j] = min(trocos[j], trocos[j-coin] + 1);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tif (trocos[troco] == INF){",
			"\t\treturn -1;",
			"\t}else{",
			"\t\treturn trocos[troco]%MOD;",
			"\t}",
			"}"
		],
		"description":"Least amount of coins needed to give change"
	},
	"Monotonic Paths":{
		"prefix":"MonotonicPath",
		"body":["//n e m arestas, NAO vertices",
						"ll Monotonic(int n, int m, ll p){\t\t\t\t//Se for n*n, usar mod(Catalan(n)*(n+1), m)",
						"\tn++;",
						"\tm++;",
						"\tvvll T(n, vll(m));",
						"\tfor (int i = 0; i < n; i++){",
						"\tT[i][0] = 1;",
						"\t}",
						"\tfor (int i = 0; i < m; i++){",
						"\tT[0][i] = 1;",
						"\t}",
						"\tfor (int i = 1; i < n; i++){",
						"\t\tfor (int j = 1; j < n; j++){",
						"\t\t\tT[i][j] = mod(mod(T[i-1][j], p) + mod(T[i][j-1], p), p);",
						"\t\t}",
						"\t}",
						"\treturn mod(T[n-1][m-1], p);",
						"}"
			],
		"description":"Numero de caminhos numa grid, indo so para baixo e direita"
	},
	"Knapsack":{
		"prefix":"knapsack",
		"body":[
						"int knapsack(int W, int n, vi price, vi weight){        //linear memory",
						"\tvi aux(W+1, 0);",
						"\tfor (int i = 0; i < n; i++){",
						"\t\tfor (int j = 1; j <= W; j++){",
						"\t\t\tif (weight[i] <= aux[j]){",
						"\t\t\t\taux[j] = max(aux[j - weight[i]] + price[i], aux[j]);",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\treturn aux[W];",
						"}"
			],
		"description":"knapsack solution with linear memory"
	}
}
