{
	"Longest Increasing Sub-sequence":{
		"prefix":"LIS",
		"body":["void printLIS(int i, vi &p, vi &arr){       //imprime LIS, sabendo o ultimo indice",
			"\tif (p[i] == -1){",
			"\t\tcout<<arr[i];",
			"\t\treturn;",
			"\t}",
			"\tprintLIS(p[i], p, arr);",
			"\tcout<<' '<<arr[i];",
			"}\n",
			"pii LIS(int n, vi &p, vi &arr){     //retorna maior LIS e o ultimo indice do maior LIS",
			"\tint k= 0, lis_end = 0;",
			"\tvi L(n, 0), L_id(n, 0);",
			"\tp.assign(n, -1);\n",
			"\tfor (int i = 0; i < n; i++){",
			"\t\tint pos = lower_bound(L.begin(), L.begin() + k, arr[i]) - L.begin();",
			"\t\tL[pos] = arr[i];",
			"\t\tL_id[pos] = i;",
			"\t\tp[i] = pos ? L_id[pos-1]:-1;",
			"\t\tif (pos == k){",
			"\t\t\tk = pos + 1;",
			"\t\t\tlis_end = i;",
			"\t\t}",
			"\t}",
			"\treturn mp(k, lis_end);",
			"}"
		],
		"description":"Maior sequencia crescente num array"
	},
	"Coin_Perm":{
		"prefix": "CoinChangePerm",
		"body":["ll coin_combs(ll change, vll &coins){",
						"\tvll dp(change + 1, 0); ",
						"\tdp[0] = 1;\n",
						"\tforsn(sub, 1, change + 1){",
						"\t\tdp[sub] = 0;",
						"\t\tfor(auto coin: coins){",
						"\t\t\tif(coin <= sub){",
						"\t\t\t\tdp[sub] = (dp[sub] + dp[sub-coin])%MOD;",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\treturn dp[change];",
						"}"
			],
		"description": "Number of permutations of coins that, when summed, are troco"
	},
	"Coin_Comb":{
		"prefix": "CoinChangeComb",
		"body":["ll coin_combs(ll change, vt<ll> &coins){",
						"\tvt<ll> dp(change + 1, 0);",
						"\tdp[0] = 1;\n",
						"\tfor(auto coin: coins){",
						"\t\tfor(int sub = 1; sub <= change; sub++){",
						"\t\t\tif(coin <= sub){",
						"\t\t\t\tdp[sub] = dp[sub] + dp[sub-coin];",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\treturn dp[change];",
						"}"
		],
		"description": "Number of combinations of coins that, when summed, are troco"
	},
	"Min_Coins":{
		"prefix":"MinCoins",
		"body":["ll min_coins(ll change, vll &coins){",
						"\tvll dp(change + 1, INF); ",
						"\tdp[0] = 0;\n",
						"\tforsn(sub, 1, change + 1){",
						"\t\tfor(auto coin: coins){",
						"\t\t\tif(coin <= sub){",
						"\t\t\t\tdp[sub] = min(dp[sub], dp[sub-coin] + 1);",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\treturn dp[change];",
						"}"
		],
		"description":"Least amount of coins needed to give change"
	},
	"Monotonic Paths":{
		"prefix":"MonotonicPath",
		"body":["//n e m arestas, NAO vertices",
						"ll Monotonic(int n, int m, ll p){\t\t\t\t//Se for n*n, usar mod(Catalan(n)*(n+1), m)",
						"\tn++;",
						"\tm++;",
						"\tvvll T(n, vll(m));",
						"\tfor (int i = 0; i < n; i++){",
						"\tT[i][0] = 1;",
						"\t}",
						"\tfor (int i = 0; i < m; i++){",
						"\tT[0][i] = 1;",
						"\t}",
						"\tfor (int i = 1; i < n; i++){",
						"\t\tfor (int j = 1; j < n; j++){",
						"\t\t\tT[i][j] = mod(mod(T[i-1][j], p) + mod(T[i][j-1], p), p);",
						"\t\t}",
						"\t}",
						"\treturn mod(T[n-1][m-1], p);",
						"}"
			],
		"description":"Numero de caminhos numa grid, indo so para baixo e direita"
	},
	"Knapsack":{
		"prefix":"knapsack",
		"body":[
						"int knapsack(int W, int n, vi price, vi weight){        //linear memory",
						"\tvi aux(W+1, 0);",
						"\tfor (int i = 0; i < n; i++){",
						"\t\tfor (int j = 1; j <= W; j++){",
						"\t\t\tif (weight[i] <= aux[j]){",
						"\t\t\t\taux[j] = max(aux[j - weight[i]] + price[i], aux[j]);",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\treturn aux[W];",
						"}"
			],
		"description":"knapsack solution with linear memory"
	},
	"BoxStacking":{
		"prefix":"BoxStacking",
		"body":["bool compareLength(vll Box1, vll Box2){",
						"\treturn Box1[0] < Box2[0];",
						"}\n",
						"bool canBeStacked(ll wTop, ll lTop, ll wBottom, ll lBottom){",
						"\treturn wTop < wBottom && lTop < lBottom;",
						"}\n",
						"ll tallestStack (vvll boxes, ll n){",
						"\tsort(all(boxes), compareLength); // sort all boxes by length ",
						"\tmap<vll, ll> heights; // memoize the tallest stack with box n at the base",
						"\tfor(auto box: boxes){",
						"\t\theights[box] = box[2];",
						"\t}\n",
						"\tfor(auto box_i: boxes){",
						"\t\tvll S; // vector of heights of stacks starting at boxes that can be stacked on top of box_i",
						"\t\tfor(auto j: boxes){",
						"\t\t\tif(canBeStacked(j[1], j[0], box_i[1], box_i[0]))",
						"\t\t\t\tS.pub(heights[j]);",
						"\t\t}",
						"\t\tif(!S.empty())",
						"\t\t\theights[box_i] = heights[box_i] + (*max_element(all(S)));",
						"\t}\n",
						"\tll maxHeight = 0; ",
						"\tfor(auto i: heights){",
						"\t\tif(i.second > maxHeight)",
						"\t\t\tmaxHeight = i.second;",
						"\t}",
						"\treturn maxHeight;",
						"}"
			],
		"description":"Dadas caixas (tamanho e peso), quantas caixas podem estar em cima umas das outras (L_top < L_bottom && W_top < W_bottom)"
	}
}
