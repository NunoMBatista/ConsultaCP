{
	"CicleFinding":{
		"prefix":"CicleFinding",
		"body":["int f(int x){               //Avançar na expressão onde estamos a encontrar ciclo",
			"\treturn (26*x + 11)%80;",
			"}\n",
			"pii floydCicleFinding(int x){             //Index (x) onde começa a sequencia (arr)",
			"\tint t = f(x), h = f(f(x));",
			"\twhile (t != h){",
			"\t\tt = f(t);",
			"\t\th = f(f(h));",
			"\t}",
			"\tint fase = 0, h = x;",
			"\twhile (t != h){",
			"\t\tt = f(t);",
			"\t\th = f(h);",
			"\t\tfase++;",
			"\t}",
			"\tint T = 1;",
			"\th = f(t);",
			"\twhile (t != h){",
			"\t\th = f(h);",
			"\t\tT++;",
			"\t}",
			"\treturn mp(T, fase);",
			"}"
		],
		"description":"Encontrar o tamanho do ciclo numa função modular"
	},
	"Exponeciação":{
		"prefix":["pow", "modPow"],
		"body":["int modPow(int b, int p, int m){",
			"\tif (p == 0) return 1;",
			"\tint ans = modPow(b, p/2, m);",
			"\tans = mod(ans*ans, m);",
			"\tif (p&1) ans = mod(ans*b, m);",
			"\treturn ans;",
			"}"
		],
		"description":"Elevar um numero eficientemente"
	},
	"Matrizes":{
		"prefix":["matPow", "matMul", "MAT"],
		"body":["vvll matMul(vvll &a, vvll &b, int MOD){              //Duas matrizes não nulas, i -> linhas, j -> colunas",
			"\tint lin = a.size();",
			"\tint col = b[0].size();",
			"\tvvll ans(lin, vll(col, 0));",
			"\tint par = b.size();",
			"\tfor (int i = 0; i < lin; i++){",
			"\t\tfor (int k = 0; k < par; k++){",
			"\t\t\tif (a[i][k] == 0) continue;",
			"\t\t\tfor (int j = 0; j < col; j++){",
			"\t\t\t\tans[i][j] += mod(a[i][k], MOD) * mod(b[k][j], MOD);",
			"\t\t\t\tans[i][j] = mod(ans[i][j], MOD);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn ans;",
			"}\n",
			"vvll matPow(vvll base, int p, int MOD){          //So matrizes quadradas",
			"\tint lin = base.size();",
			"\tvvll ans(lin, vll(lin));",
			"\tfor (int i = 0; i < lin; i++){",
			"\t\tfor (int j = 0; j < lin; j++){",
			"\t\t\tans[i][j] = (i == j);",
			"\t\t}",
			"\t}",
			"\twhile (p){",
			"\t\tif (p&1){",
			"\t\t\tans = matMul(ans, base, MOD);",
			"\t\t}",
			"\t\tbase = matMul(base, base, MOD);",
			"\t\tp >>= 1;",
			"\t}",
			"\treturn ans;",
			"}"
		],
		"description":"Operações com matrizes"
	},
	"Eliminacao de Gauss":{
		"prefix": "GaussianElimination",
		"body":["#define MAX_N 100  //adjust this value as needed",
						"struct AugmentedMatrix{ double mat[MAX_N][MAX_N + 1];};",
						"struct ColumnVector{ double vec[MAX_N];};",
						"ColumnVector GaussianElimination(int N, AugmentedMatrix Aug){    //O(n³)",
						"\t//input: N, Augmented Matriz aug; output: Column Vector x, the answer",
						"\tfor (int i = 0; i < N-1; i++){\t\t\t\t\t\t\t//forward elimination",
						"\t\tint l = i;",
						"\t\tfor (int j = i + 1; j < N; j++){\t\t\t\t\t\t\t\t\t\trow with max col value",
						"\t\t\tif (fabs(Aug.mat[j][i]) > fabs(Aug.mat[l][i])) l = j;\t\t\t\t\t\tremember this row l",
						"\t\t}",
						"\t\t//swap this pivot row, reason: minimize floating point error",
						"\t\tfor (int k = i; k <= N; k++){",
						"\t\t\tswap(Aug.mat[i][k], Aug.mat[l][k]);",
						"\t\t}",
						"\t\tfor (int j = i+1; j < N; j++){\t\t\t\t\t//actual fwd elimination",
						"\t\t\tfor (int k = N; k >= i; k--){",
						"\t\t\t\tAug.mat[j][k] -= Aug.mat[i][k] * Aug.mat[j][i] / Aug.mat[i][i];",
						"\t\t\t}",
						"\t\t}",
						"\t}",
						"\tColumnVector Ans;\t\t\t\t\t\t\t\t//back substitution phase",
						"\tfor (int j = N-1; j >= 0; j--){\t\t\t\t\t//start from back",
						"\t\tdouble t = 0.0;",
						"\t\tfor (int k = j+1; k < N; k++){",
						"\t\t\tt += Aug.mat[j][k] * Ans.vec[k];",
						"\t\t}",
						"\t\tAns.vec[j] = (Aug.mat[j][N]-t) / Aug.mat[j][j];\t\t\t\t//the answer is here",
						"\t}",
						"\treturn Ans;",
						"}",
						"",
						"int main(){",
						"\tAugmentedMatrix Aug;",
						"\tAug.mat[0][0] = 1; Aug.mat[0][1] = 1; Aug.mat[0][2] = 2; Aug.mat[0][3] = 9;\t//x + y + 2z = 9",
						"\tAug.mat[1][0] = 2; Aug.mat[1][1] = 4; Aug.mat[1][2] = 3; Aug.mat[1][3] = 1;\t//2x + 4y - 3z = 1",
						"\tAug.mat[2][0] = 3; Aug.mat[2][1] = 6; Aug.mat[2][2] = 5; Aug.mat[2][3] = 0;\t//3x + 6y - 5z = 0",
						"\tColumnVector X = GaussianElimination(3, Aug);",
						"\tcout<<\"x = \"<<X.vec[0]<<endl;",
						"\tcout<<\"y = \"<<X.vec[1]<<endl;",
						"\tcout<<\"z = \"<<X.vec[2]<<endl;",
						"}"
				],
		"description":"Eliminacao de Gauss"
	},
	"Raiz de n de um número":{
		"prefix":"raizNdeNum",
		"body":["double raizN(double a, double N){             //(a)^(1/N)",
			"\treturn pow(a, 1.0/N);",
			"}"
		],
		"description":"Raiz matemática de qualquer N (a)^(1/N)"
	},
	"countDigitos":{
		"prefix":"CountDigitos",
		"body":["int countDigitos(double num, double baseNum, double baseNova){",
			"\treturn floor(1 + log(num)/log(baseNova));",
			"}"
		],
		"description":"Digitos que um numero tem de qualquer base para qualquer base"
	},
	"MaxRangeSum1D":{
		"prefix":"MaxRangeSum1D",
		"body":["ll maxRangeSum1D(int n, vll &arr){",
			"\tll ans = 0;",
			"\t//limpeza dos negativos",
			"\tans = arr[0];",
			"\tfor (int j = 0; j < n; j++){",
			"\t\tif (arr[j] >= 0){",
			"\t\t\tans = 0;",
			"\t\t\tbreak;",
			"\t\t}else{",
			"\t\t\tif (arr[j] > ans) ans = arr[j];",
			"\t\t}",
			"\t}",
			"\tif (ans < 0) return ans;",
			"\t//fim de limpeza",
			"\tans = 0;",
			"\tll sum = 0;",
			"\tfor (int j = 0; j < n; j++){",
			"\t\tsum += arr[j];",
			"\t\tans = max(ans, sum);",
			"\t\tif (sum < 0) sum = 0;",
			"\t}",
			"\treturn ans;",
			"}"
		],
		"description":"Maxima soma de subarrays"
	},
	"MaxRangeSum2D":{
		"prefix":"MAxRangeSum2D",
		"body":["ll maxRangeSum2D(int n, vvll &mat){",
			"\tfor (int i = 0; i < n; i++){",
			"\t\tfor (int j = 1; j < n; j++){",
			"\t\t\tmat[i][j] += mat[i][j-1];",
			"\t\t}",
			"\t}",
			"\tll maior = -INF;",
			"\tfor (int i = 0; i < n; i++){",
			"\t\tfor (int j = i; j < n; j++){",
			"\t\t\tll subrect = 0;",
			"\t\t\tfor (int k = 0; k < n; k++){",
			"\t\t\t\tif (i > 0) subrect += mat[k][j] - mat[k][i-1];",
			"\t\t\t\telse subrect += mat[k][j];",
			"\t\t\t\tif (subrect < 0) subrect = 0;",
			"\t\t\t\tmaior = max(maior, subrect);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn maior;",
			"}"
		],
		"description":"Maior soma de submatrizes da matriz"
	}
}
